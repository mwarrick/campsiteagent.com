#!/bin/bash

# Pre-commit hook to check for sensitive information
# This script prevents committing passwords, API keys, and other secrets

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "ğŸ” Checking for sensitive information..."

# Get list of files being committed
FILES=$(git diff --cached --name-only --diff-filter=ACM)

# Patterns to check for (case-insensitive)
PATTERNS=(
    "password\s*=\s*['\"][^'\"]+['\"]"
    "password\s*=\s*[^[:space:]]+"
    "DB_PASSWORD\s*=\s*['\"][^'\"]+['\"]"
    "DB_PASSWORD\s*=\s*[^[:space:]]+"
    "api[_-]?key\s*=\s*['\"][^'\"]+['\"]"
    "api[_-]?key\s*=\s*[^[:space:]]+"
    "secret[_-]?key\s*=\s*['\"][^'\"]+['\"]"
    "secret[_-]?key\s*=\s*[^[:space:]]+"
    "private[_-]?key\s*=\s*['\"][^'\"]+['\"]"
    "private[_-]?key\s*=\s*[^[:space:]]+"
    "access[_-]?token\s*=\s*['\"][^'\"]+['\"]"
    "access[_-]?token\s*=\s*[^[:space:]]+"
    "mysql://[^[:space:]]+:[^[:space:]]+@"
    "postgres://[^[:space:]]+:[^[:space:]]+@"
    "mongodb://[^[:space:]]+:[^[:space:]]+@"
    "connectionString\s*=\s*['\"][^'\"]*://[^'\"]*:[^'\"]*@"
)

# Files/directories to skip (vendor files, etc.)
SKIP_PATTERNS=(
    "vendor/"
    "node_modules/"
    ".git/"
    ".gitignore"
    "package-lock.json"
    "composer.lock"
    ".env"  # .env files are expected to contain secrets, just shouldn't be in git
    "scripts/"  # Skip scripts directory (contains example patterns)
)

ERRORS=0

for file in $FILES; do
    # Skip if file matches skip patterns
    SKIP=false
    for skip_pattern in "${SKIP_PATTERNS[@]}"; do
        if [[ "$file" == *"$skip_pattern"* ]]; then
            SKIP=true
            break
        fi
    done
    
    if [ "$SKIP" = true ]; then
        continue
    fi
    
    # Check if file exists and is readable
    if [ ! -f "$file" ]; then
        continue
    fi
    
    # Check each pattern
    for pattern in "${PATTERNS[@]}"; do
        # Use grep with case-insensitive matching
        if grep -qiE "$pattern" "$file" 2>/dev/null; then
            # Check if it's a placeholder (common placeholder patterns)
            if grep -qiE "(your_|placeholder|example|sample|test_|demo_|change_me|replace_|TODO|FIXME|XXX)" "$file" 2>/dev/null; then
                # Likely a placeholder, skip
                continue
            fi
            
            # Check if it's in a comment or documentation context
            if grep -qiE "(#|//|/\*|\*|<!--|documentation|example|guide|README|DEPLOYMENT)" "$file" 2>/dev/null; then
                # Check the specific line to see if it's a placeholder
                matching_line=$(grep -iE "$pattern" "$file" | head -1)
                if echo "$matching_line" | grep -qiE "(your_|placeholder|example|sample|test_|demo_)"; then
                    # It's a placeholder in documentation, skip
                    continue
                fi
            fi
            
            echo -e "${RED}âŒ SECURITY WARNING:${NC} Potential sensitive information found in: ${YELLOW}$file${NC}"
            echo -e "   Pattern matched: ${RED}$pattern${NC}"
            echo ""
            # Show the matching line (masked)
            grep -iE "$pattern" "$file" | head -3 | while read -r line; do
                # Mask potential secrets (show first 3 and last 3 chars)
                masked=$(echo "$line" | sed -E 's/(.{3}).*(.{3})/\1***masked***\2/')
                echo -e "   ${YELLOW}$masked${NC}"
            done
            echo ""
            ERRORS=$((ERRORS + 1))
        fi
    done
done

# Check for common hardcoded credentials
echo "ğŸ” Checking for hardcoded credentials..."

HARDCODED_PATTERNS=(
    "root.*password"
    "admin.*password"
    "test.*password"
    "123456"
    "password123"
    "changeme"
)

for file in $FILES; do
    SKIP=false
    for skip_pattern in "${SKIP_PATTERNS[@]}"; do
        if [[ "$file" == *"$skip_pattern"* ]]; then
            SKIP=true
            break
        fi
    done
    
    if [ "$SKIP" = true ] || [ ! -f "$file" ]; then
        continue
    fi
    
    for pattern in "${HARDCODED_PATTERNS[@]}"; do
        if grep -qiE "$pattern" "$file" 2>/dev/null; then
            # Check if it's in a comment or documentation
            if ! grep -qiE "(comment|todo|example|test|documentation|ignore)" "$file" 2>/dev/null; then
                echo -e "${YELLOW}âš ï¸  WARNING:${NC} Possible hardcoded credential pattern in: ${YELLOW}$file${NC}"
                echo -e "   Pattern: ${YELLOW}$pattern${NC}"
                echo ""
            fi
        fi
    done
done

# Final check
if [ $ERRORS -gt 0 ]; then
    echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${RED}âŒ COMMIT BLOCKED: Found $ERRORS potential security issue(s)${NC}"
    echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo "Please review the files above and:"
    echo "  1. Remove any hardcoded passwords, API keys, or secrets"
    echo "  2. Use environment variables instead (getenv() or \$_ENV)"
    echo "  3. Ensure .env files are in .gitignore"
    echo ""
    echo "If this is a false positive, you can bypass with:"
    echo "  git commit --no-verify"
    echo ""
    exit 1
fi

echo -e "${GREEN}âœ… No sensitive information detected${NC}"
exit 0

